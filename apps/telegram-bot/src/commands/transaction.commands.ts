import { Context } from 'telegraf';
import { Markup } from 'telegraf';
import { apiService } from '../services/api.service';
import { sessionService } from '../services/session.service';
import { parseTransactionText, formatCurrency } from '../utils/parser';
import { loggers } from '../utils/logger';

async function requireAuth(ctx: Context): Promise<boolean> {
  const telegramId = ctx.from?.id;
  if (!telegramId || !await sessionService.isAuthenticated(telegramId)) {
    ctx.reply('‚ùå Voc√™ precisa fazer login primeiro.\n\nUse /login para autenticar.');
    loggers.warn('Unauthorized access attempt', { userId: telegramId });
    return false;
  }
  return true;
}

export async function addReceitaCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  loggers.command('/addreceita', ctx.from);

  await sessionService.saveUserState(telegramId, {
    step: 'awaiting_income_data',
    type: 'income',
  });

  await ctx.reply(
    'üí∞ *Adicionar Receita*\n\n' +
      'Envie o valor e descri√ß√£o da receita.\n\n' +
      '*Exemplos:*\n' +
      '‚Ä¢ `3000 Sal√°rio de janeiro`\n' +
      '‚Ä¢ `R$ 500,00 Freelance projeto XYZ`\n' +
      '‚Ä¢ `Venda de produto 250`\n\n' +
      'Ou use /cancelar para cancelar.',
    { parse_mode: 'Markdown' }
  );
}

export async function addDespesaCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  loggers.command('/adddespesa', ctx.from);

  await sessionService.saveUserState(telegramId, {
    step: 'awaiting_expense_data',
    type: 'expense',
  });

  await ctx.reply(
    'üí≥ *Adicionar Despesa*\n\n' +
      'Envie o valor e descri√ß√£o da despesa.\n\n' +
      '*Exemplos:*\n' +
      '‚Ä¢ `50 Uber para o trabalho`\n' +
      '‚Ä¢ `R$ 120,00 Supermercado`\n' +
      '‚Ä¢ `Almo√ßo no restaurante 45`\n\n' +
      'Ou use /cancelar para cancelar.',
    { parse_mode: 'Markdown' }
  );
}

export async function cancelCommand(ctx: Context) {
  const telegramId = ctx.from?.id;
  if (!telegramId) return;

  loggers.command('/cancelar', ctx.from);

  const state = await sessionService.getUserState(telegramId);
  if (!state) {
    await ctx.reply('‚ùå N√£o h√° nenhuma opera√ß√£o em andamento.');
    return;
  }

  await sessionService.clearUserState(telegramId);
  await ctx.reply('‚úÖ Opera√ß√£o cancelada.');
}

export async function editarCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/editar', ctx.from);

  try {
    await ctx.reply('‚è≥ Buscando transa√ß√µes recentes...');

    // Buscar √∫ltimas 10 transa√ß√µes
    loggers.apiRequest('GET', '/transactions', { userId: telegramId, limit: 10 });
    const result = await apiService.getTransactions(session!.accessToken, {
      limit: 10,
      offset: 0,
    });

    if (!result.data || result.data.length === 0) {
      await ctx.reply(
        'üìù Voc√™ n√£o tem transa√ß√µes para editar.\n\n' +
          'Use /addreceita ou /adddespesa para criar uma transa√ß√£o.',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    let message = '‚úèÔ∏è *Editar Transa√ß√£o*\n\n';
    message += 'Selecione uma transa√ß√£o para editar:\n\n';

    result.data.forEach((t: any, index: number) => {
      const icon = t.movementType === 'income' ? 'üí∞' : 'üí≥';
      const sign = t.movementType === 'income' ? '+' : '-';

      message += `${index + 1}. ${icon} ${sign}${formatCurrency(t.amount)}\n`;
      message += `   ${t.description || 'Sem descri√ß√£o'}\n`;
      message += `   #${t.code}\n\n`;
    });

    message += 'Digite o n√∫mero da transa√ß√£o que deseja editar:';

    await sessionService.saveUserState(telegramId, {
      step: 'awaiting_transaction_select',
      transactions: result.data,
    });

    await ctx.reply(message, { parse_mode: 'Markdown' });
  } catch (error: any) {
    loggers.apiError('GET', '/transactions', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao buscar transa√ß√µes';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

export async function handleEditTransactionFlow(ctx: Context) {
  const telegramId = ctx.from?.id;
  if (!telegramId || !ctx.message || !('text' in ctx.message)) return;

  const state = await sessionService.getUserState(telegramId);
  if (!state || !state.step?.startsWith('awaiting_transaction_')) return;

  const text = ctx.message.text;
  const session = await sessionService.getSession(telegramId);

  if (!session) {
    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Sess√£o expirada. Fa√ßa login novamente com /login');
    return;
  }

  try {
    if (state.step === 'awaiting_transaction_select') {
      const index = parseInt(text) - 1;

      if (isNaN(index) || index < 0 || index >= state.transactions.length) {
        await ctx.reply('‚ùå N√∫mero inv√°lido. Tente novamente.');
        return;
      }

      const transaction = state.transactions[index];

      const icon = transaction.movementType === 'income' ? 'üí∞' : 'üí≥';
      const sign = transaction.movementType === 'income' ? '+' : '-';

      let message = `${icon} *Transa√ß√£o Selecionada*\n\n`;
      message += `*Valor:* ${sign}${formatCurrency(transaction.amount)}\n`;
      message += `*Descri√ß√£o:* ${transaction.description || 'Sem descri√ß√£o'}\n`;
      message += `*Categoria:* ${transaction.category.name}\n`;
      message += `*Conta:* ${transaction.account.name}\n`;
      message += `*C√≥digo:* #${transaction.code}\n\n`;
      message += 'O que deseja editar?\n\n';
      message += '1Ô∏è‚É£ Valor\n';
      message += '2Ô∏è‚É£ Descri√ß√£o\n';
      message += '3Ô∏è‚É£ Excluir transa√ß√£o\n';
      message += '4Ô∏è‚É£ Cancelar\n\n';
      message += 'Digite o n√∫mero:';

      await sessionService.saveUserState(telegramId, {
        ...state,
        step: 'awaiting_edit_option',
        selectedTransaction: transaction,
      });

      await ctx.reply(message, { parse_mode: 'Markdown' });
    } else if (state.step === 'awaiting_edit_option') {
      if (text === '1') {
        await sessionService.saveUserState(telegramId, {
          ...state,
          step: 'awaiting_new_amount',
        });

        await ctx.reply(
          'üíµ Digite o novo valor:\n\n' +
            'Exemplo: 150 ou 150.00',
          { parse_mode: 'Markdown' }
        );
      } else if (text === '2') {
        await sessionService.saveUserState(telegramId, {
          ...state,
          step: 'awaiting_new_description',
        });

        await ctx.reply(
          'üìù Digite a nova descri√ß√£o:',
          { parse_mode: 'Markdown' }
        );
      } else if (text === '3') {
        // Excluir transa√ß√£o
        const transaction = state.selectedTransaction;

        try {
          await apiService.deleteTransaction(session.accessToken, transaction.id);

          await sessionService.clearUserState(telegramId);

          await ctx.reply(
            '‚úÖ *Transa√ß√£o Exclu√≠da!*\n\n' +
              `A transa√ß√£o #${transaction.code} foi removida com sucesso.`,
            { parse_mode: 'Markdown' }
          );
        } catch (error: any) {
          loggers.apiError('DELETE', `/transactions/${transaction.id}`, error, {
            userId: telegramId,
          });

          await sessionService.clearUserState(telegramId);

          const errorMessage = error.response?.data?.message || 'Erro ao excluir transa√ß√£o';
          await ctx.reply(`‚ùå ${errorMessage}`);
        }
      } else if (text === '4') {
        await sessionService.clearUserState(telegramId);
        await ctx.reply('‚úÖ Opera√ß√£o cancelada.');
      } else {
        await ctx.reply('‚ùå Op√ß√£o inv√°lida. Digite 1, 2, 3 ou 4.');
      }
    } else if (state.step === 'awaiting_new_amount') {
      const amount = parseFloat(text.replace(',', '.').replace(/[^\d.]/g, ''));

      if (isNaN(amount) || amount <= 0) {
        await ctx.reply('‚ùå Valor inv√°lido. Digite um n√∫mero maior que zero.');
        return;
      }

      const transaction = state.selectedTransaction;

      try {
        await apiService.updateTransaction(session.accessToken, transaction.id, {
          amount,
        });

        await sessionService.clearUserState(telegramId);

        await ctx.reply(
          '‚úÖ *Transa√ß√£o Atualizada!*\n\n' +
            `Novo valor: ${formatCurrency(amount)}\n` +
            `C√≥digo: #${transaction.code}`,
          { parse_mode: 'Markdown' }
        );
      } catch (error: any) {
        loggers.apiError('PATCH', `/transactions/${transaction.id}`, error, {
          userId: telegramId,
        });

        await sessionService.clearUserState(telegramId);

        const errorMessage = error.response?.data?.message || 'Erro ao atualizar transa√ß√£o';
        await ctx.reply(`‚ùå ${errorMessage}`);
      }
    } else if (state.step === 'awaiting_new_description') {
      const description = text;
      const transaction = state.selectedTransaction;

      try {
        await apiService.updateTransaction(session.accessToken, transaction.id, {
          description,
        });

        await sessionService.clearUserState(telegramId);

        await ctx.reply(
          '‚úÖ *Transa√ß√£o Atualizada!*\n\n' +
            `Nova descri√ß√£o: ${description}\n` +
            `C√≥digo: #${transaction.code}`,
          { parse_mode: 'Markdown' }
        );
      } catch (error: any) {
        loggers.apiError('PATCH', `/transactions/${transaction.id}`, error, {
          userId: telegramId,
        });

        await sessionService.clearUserState(telegramId);

        const errorMessage = error.response?.data?.message || 'Erro ao atualizar transa√ß√£o';
        await ctx.reply(`‚ùå ${errorMessage}`);
      }
    }
  } catch (error: any) {
    loggers.error('Erro no fluxo de edi√ß√£o de transa√ß√£o', error, {
      userId: telegramId,
      state,
    });

    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Erro inesperado. Tente novamente com /editar');
  }
}

export async function handleTransactionFlow(ctx: Context) {
  const telegramId = ctx.from?.id;
  if (!telegramId || !ctx.message || !('text' in ctx.message)) return;

  const state = await sessionService.getUserState(telegramId);
  if (!state) return;

  const text = ctx.message.text;

  try {
    // Handle income/expense data input
    if (state.step === 'awaiting_income_data' || state.step === 'awaiting_expense_data') {
      loggers.debug('Processing transaction input', { userId: telegramId, step: state.step, input: text });

      const parsed = parseTransactionText(text);

      if (!parsed) {
        loggers.warn('Invalid transaction format', { userId: telegramId, input: text });
        await ctx.reply(
          '‚ùå *Formato inv√°lido*\n\n' +
            'Por favor, envie no formato: `valor descri√ß√£o`\n\n' +
            'Exemplos:\n' +
            '‚Ä¢ `50 Uber para o trabalho`\n' +
            '‚Ä¢ `R$ 120,00 Supermercado`',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      loggers.info('Transaction parsed successfully', {
        userId: telegramId,
        amount: parsed.amount,
        description: parsed.description,
      });

      // Check if user has session
      const session = await sessionService.getSession(telegramId);
      if (!session) {
        loggers.sessionError('Session not found during transaction flow', telegramId);
        await sessionService.clearUserState(telegramId);
        await ctx.reply(
          '‚ùå *Sess√£o expirada*\n\n' +
            'Por favor, fa√ßa login novamente com /login',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      // Get user accounts
      try {
        loggers.apiRequest('GET', '/accounts', { userId: telegramId });
        const accounts = await apiService.getAccounts(session.accessToken);

        if (!accounts || accounts.length === 0) {
          loggers.warn('No accounts found for user', { userId: telegramId });
          await sessionService.clearUserState(telegramId);
          await ctx.reply(
            '‚ùå *Voc√™ n√£o tem contas cadastradas*\n\n' +
              'Crie uma conta primeiro usando /contas',
            {
              parse_mode: 'Markdown',
              ...Markup.inlineKeyboard([
                [Markup.button.callback('üíº Gerenciar Contas', 'accounts')],
              ])
            }
          );
          return;
        }

        loggers.info('Accounts retrieved', { userId: telegramId, count: accounts.length });

        let message = `‚úÖ Transa√ß√£o: *${formatCurrency(parsed.amount)}* - ${parsed.description}\n\n`;
        message += '*Selecione a conta:*\n\n';

        accounts.forEach((account: any, index: number) => {
          message += `${index + 1}. ${account.name} (${account.type})\n`;
        });

        message += '\nEnvie o n√∫mero da conta:';

        // Save accounts in state
        await sessionService.saveUserState(telegramId, {
          ...state,
          step: 'awaiting_account_selection',
          amount: parsed.amount,
          description: parsed.description,
          accounts,
        });

        await ctx.reply(message, { parse_mode: 'Markdown' });
      } catch (error: any) {
        loggers.apiError('GET', '/accounts', error, { userId: telegramId });
        await sessionService.clearUserState(telegramId);
        await ctx.reply(
          '‚ùå *Erro ao buscar contas*\n\n' +
            'Tente novamente mais tarde.',
          { parse_mode: 'Markdown' }
        );
      }
    }
    // Handle account selection
    else if (state.step === 'awaiting_account_selection') {
      const accountIndex = parseInt(text) - 1;

      if (isNaN(accountIndex) || accountIndex < 0 || accountIndex >= state.accounts.length) {
        loggers.warn('Invalid account selection', { userId: telegramId, input: text });
        await ctx.reply('‚ùå N√∫mero de conta inv√°lido. Tente novamente.');
        return;
      }

      const selectedAccount = state.accounts[accountIndex];
      loggers.info('Account selected', {
        userId: telegramId,
        accountId: selectedAccount.id,
        accountName: selectedAccount.name,
      });

      // Check session again
      const session = await sessionService.getSession(telegramId);
      if (!session) {
        loggers.sessionError('Session not found during account selection', telegramId);
        await sessionService.clearUserState(telegramId);
        await ctx.reply(
          '‚ùå *Sess√£o expirada*\n\n' +
            'Por favor, fa√ßa login novamente com /login',
          { parse_mode: 'Markdown' }
        );
        return;
      }

      try {
        // Use AI to suggest category
        loggers.apiRequest('POST', '/ai/suggest-category', {
          userId: telegramId,
          description: state.description,
        });

        const suggestion = await apiService.suggestCategory(
          session.accessToken,
          state.description
        );

        loggers.info('Category suggested', {
          userId: telegramId,
          category: suggestion.category,
          subcategory: suggestion.subcategory,
          confidence: suggestion.confidence,
        });

        // Get categories
        const categories = await apiService.getCategories(session.accessToken);
        const category = categories.find((c: any) => c.name === suggestion.category);

        if (!category) {
          loggers.error('Category not found', undefined, {
            userId: telegramId,
            suggestedCategory: suggestion.category,
          });
          await sessionService.clearUserState(telegramId);
          await ctx.reply('‚ùå Erro ao buscar categorias. Tente novamente.');
          return;
        }

        // Create transaction with suggested category
        const transactionData: any = {
          accountId: selectedAccount.id,
          categoryId: category.id,
          movementType: state.type,
          launchType: state.type, // income, expense, investment, transfer
          amount: state.amount,
          description: state.description,
          isRecurring: false, // Transa√ß√µes simples n√£o s√£o recorrentes
          // Adicionar data correta baseada no tipo
          ...(state.type === 'expense' 
            ? { dueDate: new Date().toISOString() } // Data de vencimento para despesas
            : { receiptDate: new Date().toISOString() } // Data de recebimento para receitas
          ),
        };

        // If there's a subcategory suggestion, try to find it
        if (suggestion.subcategory) {
          const subcategories = await apiService.getSubcategories(
            session.accessToken,
            category.id
          );
          const subcategory = subcategories.find((s: any) => s.name === suggestion.subcategory);
          if (subcategory) {
            transactionData.subcategoryId = subcategory.id;
          }
        }

        loggers.apiRequest('POST', '/transactions', {
          userId: telegramId,
          data: transactionData,
        });

        const transaction = await apiService.createTransaction(
          session.accessToken,
          transactionData
        );

        loggers.info('Transaction created successfully', {
          userId: telegramId,
          transactionId: transaction.id,
          amount: state.amount,
          type: state.type,
        });

        await sessionService.clearUserState(telegramId);

        const icon = state.type === 'income' ? 'üí∞' : 'üí≥';
        const typeLabel = state.type === 'income' ? 'Receita' : 'Despesa';

        await ctx.reply(
          `${icon} *${typeLabel} Registrada!*\n\n` +
            `*Valor:* ${formatCurrency(state.amount)}\n` +
            `*Descri√ß√£o:* ${state.description}\n` +
            `*Conta:* ${selectedAccount.name}\n` +
            `*Categoria:* ${category.name}${suggestion.subcategory ? ` > ${suggestion.subcategory}` : ''}\n` +
            `*C√≥digo:* #${transaction.code}\n\n` +
            '‚úÖ Transa√ß√£o salva com sucesso!',
          { parse_mode: 'Markdown' }
        );
      } catch (error: any) {
        loggers.apiError('POST', '/transactions', error, {
          userId: telegramId,
          transactionData: {
            amount: state.amount,
            description: state.description,
            type: state.type,
          },
        });

        await sessionService.clearUserState(telegramId);

        const errorMessage = error.response?.data?.message || 'Erro ao processar transa√ß√£o';
        const errorDetails = error.response?.data?.error || '';

        await ctx.reply(
          `‚ùå *Erro ao criar transa√ß√£o*\n\n` +
            `${errorMessage}\n` +
            (errorDetails ? `\n_Detalhes: ${errorDetails}_\n` : '') +
            '\nTente novamente com /addreceita ou /adddespesa',
          { parse_mode: 'Markdown' }
        );
      }
    }
  } catch (error: any) {
    loggers.flowError('transaction', state.step, error, {
      userId: telegramId,
      state,
    });

    await sessionService.clearUserState(telegramId);
    await ctx.reply(
      '‚ùå Erro inesperado. Use /addreceita ou /adddespesa para tentar novamente.'
    );
  }
}
