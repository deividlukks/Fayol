import { Context } from 'telegraf';
import { Markup } from 'telegraf';
import { apiService } from '../services/api.service';
import { sessionService } from '../services/session.service';
import { formatCurrency } from '../utils/parser';
import { loggers } from '../utils/logger';

async function requireAuth(ctx: Context): Promise<boolean> {
  const telegramId = ctx.from?.id;
  if (!telegramId || !await sessionService.isAuthenticated(telegramId)) {
    ctx.reply('‚ùå Voc√™ precisa fazer login primeiro.\n\nUse /login para autenticar.');
    loggers.warn('Unauthorized access attempt', { userId: telegramId });
    return false;
  }
  return true;
}

export async function orcamentosCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/orcamentos', ctx.from);

  try {
    await ctx.reply('‚è≥ Buscando seus or√ßamentos...');

    loggers.apiRequest('GET', '/budgets/status', { userId: telegramId });
    const budgets = await apiService.getBudgetStatus(session!.accessToken);

    if (!budgets || budgets.length === 0) {
      await ctx.reply(
        'üìä *Or√ßamentos*\n\n' +
          'Voc√™ ainda n√£o tem or√ßamentos configurados.\n\n' +
          'Use /novoorcamento para criar um!',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    let message = 'üìä *Seus Or√ßamentos*\n\n';

    budgets.forEach((budget: any) => {
      const icon = budget.isOverBudget ? 'üî¥' :
                   budget.isNearLimit ? 'üü°' : 'üü¢';

      message += `${icon} *${budget.name}*\n`;
      message += `Categoria: ${budget.category}\n`;
      message += `Per√≠odo: ${translatePeriod(budget.period)}\n`;
      message += `Or√ßamento: ${formatCurrency(budget.amount)}\n`;
      message += `Gasto: ${formatCurrency(budget.spent)} (${budget.percentage}%)\n`;
      message += `Dispon√≠vel: ${formatCurrency(budget.remaining)}\n`;

      if (budget.isOverBudget) {
        message += `‚ö†Ô∏è *ATEN√á√ÉO: Or√ßamento ultrapassado!*\n`;
      } else if (budget.isNearLimit) {
        message += `‚ö° Pr√≥ximo do limite (${budget.alertThreshold}%)\n`;
      }

      message += '\n';
    });

    message += '_Use /novoorcamento para criar um novo or√ßamento_';

    await ctx.reply(message, { parse_mode: 'Markdown' });
  } catch (error: any) {
    loggers.apiError('GET', '/budgets/status', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao buscar or√ßamentos';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

export async function novoOrcamentoCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  loggers.command('/novoorcamento', ctx.from);

  await sessionService.saveUserState(telegramId, {
    step: 'awaiting_budget_name',
    budgetData: {},
  });

  await ctx.reply(
    'üí∞ *Criar Novo Or√ßamento*\n\n' +
      'Qual ser√° o nome do or√ßamento?\n\n' +
      'Exemplos:\n' +
      '‚Ä¢ `Alimenta√ß√£o Mensal`\n' +
      '‚Ä¢ `Or√ßamento de Transporte`\n' +
      '‚Ä¢ `Lazer e Entretenimento`\n\n' +
      'Ou use /cancelar para cancelar.',
    { parse_mode: 'Markdown' }
  );
}

export async function alertasCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/alertas', ctx.from);

  try {
    await ctx.reply('‚è≥ Buscando alertas...');

    loggers.apiRequest('GET', '/budgets/alerts/unread', { userId: telegramId });
    const alerts = await apiService.getUnreadAlerts(session!.accessToken);

    if (!alerts || alerts.length === 0) {
      await ctx.reply(
        'üîî *Alertas*\n\n' +
          'Voc√™ n√£o tem alertas n√£o lidos.\n\n' +
          '‚úÖ Tudo certo com seus or√ßamentos!',
        { parse_mode: 'Markdown' }
      );
      return;
    }

    let message = 'üîî *Alertas de Or√ßamento*\n\n';

    alerts.forEach((alert: any, index: number) => {
      const date = new Date(alert.createdAt);
      const dateStr = date.toLocaleDateString('pt-BR');

      message += `${index + 1}. ${alert.message}\n`;
      message += `   üìÖ ${dateStr}\n\n`;
    });

    message += `_Total: ${alerts.length} alerta(s) n√£o lido(s)_`;

    await ctx.reply(message, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ Marcar todos como lidos', 'mark_all_alerts_read')],
      ])
    });
  } catch (error: any) {
    loggers.apiError('GET', '/budgets/alerts/unread', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao buscar alertas';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

export async function handleBudgetFlow(ctx: Context) {
  const telegramId = ctx.from?.id;
  if (!telegramId || !ctx.message || !('text' in ctx.message)) return;

  const state = await sessionService.getUserState(telegramId);
  if (!state || !state.step?.startsWith('awaiting_budget_')) return;

  const text = ctx.message.text;
  const session = await sessionService.getSession(telegramId);

  if (!session) {
    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Sess√£o expirada. Fa√ßa login novamente com /login');
    return;
  }

  try {
    if (state.step === 'awaiting_budget_name') {
      await sessionService.saveUserState(telegramId, {
        ...state,
        step: 'awaiting_budget_amount',
        budgetData: { ...state.budgetData, name: text },
      });

      await ctx.reply(
        'üíµ Qual ser√° o valor do or√ßamento?\n\n' +
          'Envie apenas o valor (ex: 1500 ou 1500.00)',
        { parse_mode: 'Markdown' }
      );
    } else if (state.step === 'awaiting_budget_amount') {
      const amount = parseFloat(text.replace(',', '.').replace(/[^\d.]/g, ''));

      if (isNaN(amount) || amount <= 0) {
        await ctx.reply('‚ùå Valor inv√°lido. Digite um n√∫mero maior que zero.');
        return;
      }

      await sessionService.saveUserState(telegramId, {
        ...state,
        step: 'awaiting_budget_period',
        budgetData: { ...state.budgetData, amount },
      });

      await ctx.reply(
        'üìÖ Qual ser√° o per√≠odo do or√ßamento?\n\n' +
          '1Ô∏è‚É£ Di√°rio\n' +
          '2Ô∏è‚É£ Semanal\n' +
          '3Ô∏è‚É£ Mensal\n' +
          '4Ô∏è‚É£ Anual\n\n' +
          'Digite o n√∫mero correspondente:',
        { parse_mode: 'Markdown' }
      );
    } else if (state.step === 'awaiting_budget_period') {
      const periods: { [key: string]: string } = {
        '1': 'daily',
        '2': 'weekly',
        '3': 'monthly',
        '4': 'yearly',
      };

      const period = periods[text];
      if (!period) {
        await ctx.reply('‚ùå Op√ß√£o inv√°lida. Digite 1, 2, 3 ou 4.');
        return;
      }

      await sessionService.saveUserState(telegramId, {
        ...state,
        step: 'awaiting_budget_category',
        budgetData: { ...state.budgetData, period },
      });

      // Buscar categorias
      const categories = await apiService.getCategories(session.accessToken);
      const expenseCategories = categories.filter((c: any) => c.type === 'expense');

      let message = 'üìÅ Escolha uma categoria (ou digite 0 para geral):\n\n';
      message += '0Ô∏è‚É£ Or√ßamento Geral (todas as despesas)\n\n';

      expenseCategories.forEach((cat: any, index: number) => {
        message += `${index + 1}Ô∏è‚É£ ${cat.name}\n`;
      });

      message += '\nDigite o n√∫mero:';

      await sessionService.saveUserState(telegramId, {
        ...state,
        step: 'awaiting_budget_category',
        budgetData: { ...state.budgetData, period },
        categories: expenseCategories,
      });

      await ctx.reply(message);
    } else if (state.step === 'awaiting_budget_category') {
      const choice = parseInt(text);

      if (isNaN(choice) || choice < 0 || choice > state.categories.length) {
        await ctx.reply('‚ùå Op√ß√£o inv√°lida.');
        return;
      }

      const categoryId = choice === 0 ? null : state.categories[choice - 1].id;
      const categoryName = choice === 0 ? 'Geral' : state.categories[choice - 1].name;

      // Criar or√ßamento
      const budgetData = {
        name: state.budgetData.name,
        amount: state.budgetData.amount,
        period: state.budgetData.period,
        categoryId,
        startDate: new Date().toISOString(),
        alertThreshold: 80, // Padr√£o: 80%
        isActive: true,
      };

      loggers.apiRequest('POST', '/budgets', { userId: telegramId, data: budgetData });
      const budget = await apiService.createBudget(session.accessToken, budgetData);

      await sessionService.clearUserState(telegramId);

      await ctx.reply(
        '‚úÖ *Or√ßamento Criado com Sucesso!*\n\n' +
          `üìã *Nome:* ${budget.name}\n` +
          `üíµ *Valor:* ${formatCurrency(budget.amount)}\n` +
          `üìÖ *Per√≠odo:* ${translatePeriod(budget.period)}\n` +
          `üìÅ *Categoria:* ${categoryName}\n` +
          `‚ö° *Alerta em:* ${budget.alertThreshold}%\n\n` +
          'üîî Voc√™ receber√° alertas quando atingir o limite configurado!\n\n' +
          'Use /orcamentos para ver todos os seus or√ßamentos.',
        { parse_mode: 'Markdown' }
      );
    }
  } catch (error: any) {
    loggers.error('Erro no fluxo de or√ßamento', error, { userId: telegramId, state });
    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Erro ao criar or√ßamento. Tente novamente com /novoorcamento');
  }
}

function translatePeriod(period: string): string {
  const translations: { [key: string]: string } = {
    daily: 'Di√°rio',
    weekly: 'Semanal',
    monthly: 'Mensal',
    yearly: 'Anual',
  };
  return translations[period] || period;
}
