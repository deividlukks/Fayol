import { Context } from 'telegraf';
import { apiService } from '../services/api.service';
import { sessionService } from '../services/session.service';
import { formatCurrency, formatDate, formatDateTime } from '../utils/parser';
import { loggers } from '../utils/logger';

async function requireAuth(ctx: Context): Promise<boolean> {
  const telegramId = ctx.from?.id;
  if (!telegramId || !await sessionService.isAuthenticated(telegramId)) {
    loggers.warn('Unauthorized access attempt', { userId: telegramId });
    ctx.reply('‚ùå Voc√™ precisa fazer login primeiro.\n\nUse /login para autenticar.');
    return false;
  }
  return true;
}

export async function saldoCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/saldo', ctx.from);

  try {
    await ctx.reply('‚è≥ Consultando saldo...');

    loggers.apiRequest('GET', '/dashboard/balance', { userId: telegramId });
    const balance = await apiService.getBalance(session!.accessToken);

    loggers.apiRequest('GET', '/dashboard/summary-cards', { userId: telegramId });
    const summaryCards = await apiService.getSummaryCards(session!.accessToken);

    loggers.info('Balance retrieved successfully', { userId: telegramId });

    let message = 'üí∞ *Saldo Geral*\n\n';
    message += `*Total:* ${formatCurrency(balance.totalBalance)}\n\n`;

    message += 'üìä *Resumo do M√™s*\n\n';
    message += `üíµ Receitas: ${formatCurrency(summaryCards.totalIncome)}\n`;
    message += `üí≥ Despesas: ${formatCurrency(summaryCards.totalExpenses)}\n`;
    message += `üí∞ Saldo: ${formatCurrency(summaryCards.balance)}\n`;
    message += `üìà Investimentos: ${formatCurrency(summaryCards.totalInvestments)}\n\n`;

    if (balance.accounts && balance.accounts.length > 0) {
      message += 'üíº *Contas:*\n\n';
      balance.accounts.forEach((account: any) => {
        const icon = account.type === 'checking' ? 'üè¶' :
                     account.type === 'savings' ? 'üíé' :
                     account.type === 'wallet' ? 'üëõ' : 'üí≥';
        message += `${icon} ${account.name}: ${formatCurrency(account.balance)}\n`;
      });
    }

    await ctx.reply(message, { parse_mode: 'Markdown' });
  } catch (error: any) {
    loggers.apiError('GET', '/dashboard/balance', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao buscar saldo';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

export async function extratoCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/extrato', ctx.from);

  try {
    await ctx.reply('‚è≥ Buscando √∫ltimas transa√ß√µes...');

    loggers.apiRequest('GET', '/transactions', { userId: telegramId, limit: 10 });
    const result = await apiService.getTransactions(session!.accessToken, {
      limit: 10,
      offset: 0,
    });

    loggers.info('Transactions retrieved successfully', {
      userId: telegramId,
      count: result.transactions?.length || 0,
    });

    if (!result.transactions || result.transactions.length === 0) {
      await ctx.reply('üìù Voc√™ ainda n√£o tem transa√ß√µes registradas.\n\nUse /addreceita ou /adddespesa para come√ßar!');
      return;
    }

    let message = 'üìù *√öltimas Transa√ß√µes*\n\n';

    result.transactions.forEach((t: any) => {
      const icon = t.movementType === 'income' ? 'üí∞' :
                   t.movementType === 'expense' ? 'üí≥' :
                   t.movementType === 'investment' ? 'üìà' : 'üîÑ';

      const sign = t.movementType === 'income' ? '+' : '-';

      message += `${icon} *${sign}${formatCurrency(t.amount)}*\n`;
      message += `${t.description}\n`;
      message += `üìÅ ${t.category.name}`;
      if (t.subcategory) {
        message += ` > ${t.subcategory.name}`;
      }
      message += `\nüìÖ ${formatDate(t.transactionDate)}\n`;
      message += `#${t.code}\n\n`;
    });

    message += `_Mostrando ${result.transactions.length} de ${result.total} transa√ß√µes_`;

    await ctx.reply(message, { parse_mode: 'Markdown' });
  } catch (error: any) {
    loggers.apiError('GET', '/transactions', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao buscar extrato';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

export async function relatorioCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  const session = await sessionService.getSession(telegramId);

  loggers.command('/relatorio', ctx.from);

  try {
    await ctx.reply('‚è≥ Gerando relat√≥rio mensal...');

    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth() + 1;

    loggers.apiRequest('GET', `/reports/monthly/${year}/${month}`, { userId: telegramId });
    const report = await apiService.getMonthlyReport(session!.accessToken, year, month);

    loggers.apiRequest('GET', '/reports/spending-by-category', { userId: telegramId });
    const spending = await apiService.getSpendingByCategory(session!.accessToken);

    loggers.info('Report generated successfully', {
      userId: telegramId,
      year,
      month,
    });

    let message = `üìä *Relat√≥rio Mensal*\n`;
    message += `üìÖ ${getMonthName(month)}/${year}\n\n`;

    message += 'üí∞ *Resumo Financeiro*\n\n';
    message += `üíµ Receitas: ${formatCurrency(report.totalIncome)}\n`;
    message += `üí≥ Despesas: ${formatCurrency(report.totalExpenses)}\n`;
    message += `üí∞ Saldo: ${formatCurrency(report.balance)}\n`;
    message += `üìà Investimentos: ${formatCurrency(report.totalInvestments)}\n\n`;

    if (report.savingsRate !== undefined) {
      const savingsEmoji = report.savingsRate > 20 ? 'üéØ' :
                          report.savingsRate > 10 ? 'üëç' : '‚ö†Ô∏è';
      message += `${savingsEmoji} Taxa de Economia: ${report.savingsRate.toFixed(1)}%\n\n`;
    }

    if (spending && spending.length > 0) {
      message += 'üìÅ *Gastos por Categoria*\n\n';

      spending.slice(0, 5).forEach((cat: any) => {
        message += `${cat.category}: ${formatCurrency(cat.total)} (${cat.percentage.toFixed(1)}%)\n`;
      });

      if (spending.length > 5) {
        message += `\n_e mais ${spending.length - 5} categorias..._\n`;
      }
    }

    await ctx.reply(message, { parse_mode: 'Markdown' });
  } catch (error: any) {
    loggers.apiError('GET', '/reports', error, { userId: telegramId });
    const errorMessage = error.response?.data?.message || 'Erro ao gerar relat√≥rio';
    await ctx.reply(`‚ùå ${errorMessage}`);
  }
}

function getMonthName(month: number): string {
  const months = [
    'Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
    'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
  ];
  return months[month - 1] || '';
}
