import { Context } from 'telegraf';
import { apiService } from '../services/api.service';
import { sessionService } from '../services/session.service';
import { loggers } from '../utils/logger';
import axios from 'axios';
import { InputFile } from 'telegraf/types';

async function requireAuth(ctx: Context): Promise<boolean> {
  const telegramId = ctx.from?.id;
  if (!telegramId || !await sessionService.isAuthenticated(telegramId)) {
    ctx.reply('‚ùå Voc√™ precisa fazer login primeiro.\n\nUse /login para autenticar.');
    loggers.warn('Unauthorized access attempt', { userId: telegramId });
    return false;
  }
  return true;
}

export async function graficosCommand(ctx: Context) {
  if (!await requireAuth(ctx)) return;

  const telegramId = ctx.from!.id;
  loggers.command('/graficos', ctx.from);

  await ctx.reply(
    'üìä *Gr√°ficos Dispon√≠veis*\n\n' +
      'Escolha qual gr√°fico deseja visualizar:\n\n' +
      '1Ô∏è‚É£ Gastos por Categoria (Pizza)\n' +
      '2Ô∏è‚É£ Receitas vs Despesas (Barras)\n' +
      '3Ô∏è‚É£ Evolu√ß√£o do Saldo (Linha)\n' +
      '4Ô∏è‚É£ Todos os gr√°ficos\n\n' +
      'Digite o n√∫mero ou use /cancelar:',
    { parse_mode: 'Markdown' }
  );

  await sessionService.saveUserState(telegramId, {
    step: 'awaiting_chart_selection',
  });
}

export async function handleChartFlow(ctx: Context) {
  const telegramId = ctx.from?.id;
  if (!telegramId || !ctx.message || !('text' in ctx.message)) return;

  const state = await sessionService.getUserState(telegramId);
  if (!state || state.step !== 'awaiting_chart_selection') return;

  const text = ctx.message.text;
  const session = await sessionService.getSession(telegramId);

  if (!session) {
    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Sess√£o expirada. Fa√ßa login novamente com /login');
    return;
  }

  try {
    const choice = text.trim();

    if (choice === '1') {
      await sendSpendingByCategory(ctx, session.accessToken);
    } else if (choice === '2') {
      await sendMonthlyComparison(ctx, session.accessToken);
    } else if (choice === '3') {
      await sendBalanceEvolution(ctx, session.accessToken);
    } else if (choice === '4') {
      await ctx.reply('üìä Gerando todos os gr√°ficos... Isso pode levar alguns segundos.');
      await sendSpendingByCategory(ctx, session.accessToken);
      await sendMonthlyComparison(ctx, session.accessToken);
      await sendBalanceEvolution(ctx, session.accessToken);
    } else {
      await ctx.reply('‚ùå Op√ß√£o inv√°lida. Digite 1, 2, 3 ou 4.');
      return;
    }

    await sessionService.clearUserState(telegramId);
  } catch (error: any) {
    loggers.error('Erro no fluxo de gr√°ficos', error, { userId: telegramId });
    await sessionService.clearUserState(telegramId);
    await ctx.reply('‚ùå Erro ao gerar gr√°fico. Tente novamente com /graficos');
  }
}

async function sendSpendingByCategory(ctx: Context, token: string) {
  try {
    await ctx.reply('üìä Gerando gr√°fico de gastos por categoria...');

    const chartData = await apiService.getChart(token, 'spending-by-category');

    if (!chartData || !chartData.chartUrl) {
      await ctx.reply('‚ùå N√£o h√° dados suficientes para gerar o gr√°fico.');
      return;
    }

    // Download da imagem
    const response = await axios.get(chartData.chartUrl, {
      responseType: 'arraybuffer',
    });

    const imageBuffer = Buffer.from(response.data);

    // Enviar imagem
    await ctx.replyWithPhoto(
      { source: imageBuffer },
      {
        caption: 'üìä *Gastos por Categoria*\n\nDistribui√ß√£o percentual dos seus gastos no m√™s atual.',
        parse_mode: 'Markdown',
      }
    );

    loggers.info('Chart sent successfully', {
      userId: ctx.from!.id,
      type: 'spending-by-category'
    });
  } catch (error: any) {
    loggers.error('Erro ao enviar gr√°fico de gastos', error, {
      userId: ctx.from!.id
    });
    await ctx.reply('‚ùå Erro ao gerar gr√°fico de gastos por categoria.');
  }
}

async function sendMonthlyComparison(ctx: Context, token: string) {
  try {
    await ctx.reply('üìä Gerando gr√°fico de compara√ß√£o mensal...');

    const chartData = await apiService.getChart(token, 'monthly-comparison');

    if (!chartData || !chartData.chartUrl) {
      await ctx.reply('‚ùå N√£o h√° dados suficientes para gerar o gr√°fico.');
      return;
    }

    const response = await axios.get(chartData.chartUrl, {
      responseType: 'arraybuffer',
    });

    const imageBuffer = Buffer.from(response.data);

    await ctx.replyWithPhoto(
      { source: imageBuffer },
      {
        caption: 'üìä *Receitas vs Despesas*\n\nEvolu√ß√£o dos seus gastos e receitas nos √∫ltimos 6 meses.',
        parse_mode: 'Markdown',
      }
    );

    loggers.info('Chart sent successfully', {
      userId: ctx.from!.id,
      type: 'monthly-comparison'
    });
  } catch (error: any) {
    loggers.error('Erro ao enviar gr√°fico de compara√ß√£o', error, {
      userId: ctx.from!.id
    });
    await ctx.reply('‚ùå Erro ao gerar gr√°fico de compara√ß√£o mensal.');
  }
}

async function sendBalanceEvolution(ctx: Context, token: string) {
  try {
    await ctx.reply('üìä Gerando gr√°fico de evolu√ß√£o do saldo...');

    const chartData = await apiService.getChart(token, 'balance-evolution');

    if (!chartData || !chartData.chartUrl) {
      await ctx.reply('‚ùå N√£o h√° dados suficientes para gerar o gr√°fico.');
      return;
    }

    const response = await axios.get(chartData.chartUrl, {
      responseType: 'arraybuffer',
    });

    const imageBuffer = Buffer.from(response.data);

    await ctx.replyWithPhoto(
      { source: imageBuffer },
      {
        caption: 'üìä *Evolu√ß√£o do Saldo*\n\nComo seu saldo evoluiu nos √∫ltimos 30 dias.',
        parse_mode: 'Markdown',
      }
    );

    loggers.info('Chart sent successfully', {
      userId: ctx.from!.id,
      type: 'balance-evolution'
    });
  } catch (error: any) {
    loggers.error('Erro ao enviar gr√°fico de evolu√ß√£o', error, {
      userId: ctx.from!.id
    });
    await ctx.reply('‚ùå Erro ao gerar gr√°fico de evolu√ß√£o do saldo.');
  }
}
