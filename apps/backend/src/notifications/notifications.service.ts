import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { PrismaService } from '../prisma/prisma.service';
import axios from 'axios';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class NotificationsService {
  private readonly logger = new Logger(NotificationsService.name);
  private readonly telegramBotToken: string;
  private readonly telegramApiUrl: string;

  constructor(
    private prisma: PrismaService,
    private configService: ConfigService,
  ) {
    this.telegramBotToken = this.configService.get('TELEGRAM_BOT_TOKEN') || '';
    this.telegramApiUrl = `https://api.telegram.org/bot${this.telegramBotToken}`;
  }

  /**
   * Cron que roda diariamente √†s 20:00 para verificar usu√°rios
   * que n√£o registraram transa√ß√µes no dia
   */
  @Cron('0 20 * * *', {
    name: 'daily-transaction-reminder',
    timeZone: 'America/Sao_Paulo',
  })
  async sendDailyTransactionReminder() {
    this.logger.log('üîî Iniciando envio de lembretes di√°rios...');

    try {
      // Buscar todos os usu√°rios ativos
      const users = await this.prisma.user.findMany({
        where: {
          isActive: true,
        },
        select: {
          id: true,
          name: true,
          phone: true, // Telegram ID pode estar no phone
        },
      });

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      let sentCount = 0;
      let skippedCount = 0;

      for (const user of users) {
        // Verificar se o usu√°rio registrou transa√ß√µes hoje
        const todayTransactions = await this.prisma.transaction.count({
          where: {
            userId: user.id,
            createdAt: {
              gte: today,
            },
          },
        });

        if (todayTransactions === 0) {
          // Usu√°rio n√£o registrou transa√ß√µes hoje
          // Verificar se n√£o enviamos lembrete recentemente (√∫ltimas 24h)
          const recentNotification = await this.prisma.notification.findFirst({
            where: {
              userId: user.id,
              type: 'reminder',
              createdAt: {
                gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
              },
            },
          });

          if (!recentNotification) {
            await this.sendTelegramReminder(user);

            // Registrar notifica√ß√£o
            await this.prisma.notification.create({
              data: {
                userId: user.id,
                type: 'reminder',
                title: 'Lembrete de Registro',
                message: 'Voc√™ ainda n√£o registrou transa√ß√µes hoje',
              },
            });

            sentCount++;
          } else {
            skippedCount++;
          }
        }
      }

      this.logger.log(
        `‚úÖ Lembretes enviados: ${sentCount} | Ignorados: ${skippedCount}`
      );
    } catch (error) {
      this.logger.error('Erro ao enviar lembretes di√°rios', error);
    }
  }

  /**
   * Cron que roda toda segunda-feira √†s 09:00 para enviar
   * resumo semanal
   */
  @Cron('0 9 * * 1', {
    name: 'weekly-summary',
    timeZone: 'America/Sao_Paulo',
  })
  async sendWeeklySummary() {
    this.logger.log('üìä Iniciando envio de resumos semanais...');

    try {
      const users = await this.prisma.user.findMany({
        where: {
          isActive: true,
        },
        select: {
          id: true,
          name: true,
          phone: true,
        },
      });

      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      let sentCount = 0;

      for (const user of users) {
        const transactions = await this.prisma.transaction.findMany({
          where: {
            userId: user.id,
            createdAt: {
              gte: oneWeekAgo,
            },
          },
        });

        if (transactions.length > 0) {
          const totalIncome = transactions
            .filter(t => t.movementType === 'income')
            .reduce((sum, t) => sum + t.amount.toNumber(), 0);

          const totalExpenses = transactions
            .filter(t => t.movementType === 'expense')
            .reduce((sum, t) => sum + t.amount.toNumber(), 0);

          const balance = totalIncome - totalExpenses;

          await this.sendTelegramWeeklySummary(user, {
            totalIncome,
            totalExpenses,
            balance,
            transactionCount: transactions.length,
          });

          // Registrar notifica√ß√£o
          await this.prisma.notification.create({
            data: {
              userId: user.id,
              type: 'recommendation',
              title: 'Resumo Semanal',
              message: `Voc√™ registrou ${transactions.length} transa√ß√µes esta semana`,
              data: {
                totalIncome,
                totalExpenses,
                balance,
              },
            },
          });

          sentCount++;
        }
      }

      this.logger.log(`‚úÖ Resumos semanais enviados: ${sentCount}`);
    } catch (error) {
      this.logger.error('Erro ao enviar resumos semanais', error);
    }
  }

  /**
   * Cron que roda no primeiro dia do m√™s √†s 10:00
   * para enviar relat√≥rio mensal
   */
  @Cron('0 10 1 * *', {
    name: 'monthly-report',
    timeZone: 'America/Sao_Paulo',
  })
  async sendMonthlyReport() {
    this.logger.log('üìà Iniciando envio de relat√≥rios mensais...');

    try {
      const users = await this.prisma.user.findMany({
        where: {
          isActive: true,
        },
        select: {
          id: true,
          name: true,
          phone: true,
        },
      });

      const lastMonth = new Date();
      lastMonth.setMonth(lastMonth.getMonth() - 1);
      const year = lastMonth.getFullYear();
      const month = lastMonth.getMonth() + 1;

      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0, 23, 59, 59);

      let sentCount = 0;

      for (const user of users) {
        const transactions = await this.prisma.transaction.findMany({
          where: {
            userId: user.id,
            effectiveDate: {
              gte: startDate,
              lte: endDate,
            },
          },
          include: {
            category: true,
          },
        });

        if (transactions.length > 0) {
          const totalIncome = transactions
            .filter(t => t.movementType === 'income')
            .reduce((sum, t) => sum + t.amount.toNumber(), 0);

          const totalExpenses = transactions
            .filter(t => t.movementType === 'expense')
            .reduce((sum, t) => sum + t.amount.toNumber(), 0);

          const balance = totalIncome - totalExpenses;

          // Categoria com mais gastos
          const categoryMap = new Map<string, number>();
          transactions
            .filter(t => t.movementType === 'expense')
            .forEach(t => {
              const current = categoryMap.get(t.category.name) || 0;
              categoryMap.set(t.category.name, current + t.amount.toNumber());
            });

          const topCategory = Array.from(categoryMap.entries())
            .sort((a, b) => b[1] - a[1])[0];

          await this.sendTelegramMonthlyReport(user, {
            month: this.getMonthName(month),
            year,
            totalIncome,
            totalExpenses,
            balance,
            transactionCount: transactions.length,
            topCategory: topCategory ? topCategory[0] : 'N/A',
            topCategoryAmount: topCategory ? topCategory[1] : 0,
          });

          sentCount++;
        }
      }

      this.logger.log(`‚úÖ Relat√≥rios mensais enviados: ${sentCount}`);
    } catch (error) {
      this.logger.error('Erro ao enviar relat√≥rios mensais', error);
    }
  }

  /**
   * Verificar or√ßamentos pr√≥ximos do limite
   * Roda a cada 6 horas
   */
  @Cron('0 */6 * * *', {
    name: 'budget-check',
    timeZone: 'America/Sao_Paulo',
  })
  async checkBudgetLimits() {
    this.logger.log('üí∞ Verificando limites de or√ßamento...');

    try {
      // Buscar alertas n√£o lidos recentes (√∫ltimas 6 horas)
      const recentAlerts = await this.prisma.budgetAlert.findMany({
        where: {
          isRead: false,
          createdAt: {
            gte: new Date(Date.now() - 6 * 60 * 60 * 1000),
          },
        },
        include: {
          budget: {
            include: {
              user: true,
              category: true,
            },
          },
        },
      });

      let sentCount = 0;

      for (const alert of recentAlerts) {
        await this.sendTelegramBudgetAlert(alert.budget.user, alert);
        sentCount++;
      }

      this.logger.log(`‚úÖ Alertas de or√ßamento enviados: ${sentCount}`);
    } catch (error) {
      this.logger.error('Erro ao verificar limites de or√ßamento', error);
    }
  }

  /**
   * Enviar mensagem via Telegram
   */
  private async sendTelegramMessage(chatId: string, text: string): Promise<void> {
    try {
      await axios.post(`${this.telegramApiUrl}/sendMessage`, {
        chat_id: chatId,
        text,
        parse_mode: 'Markdown',
      });
    } catch (error) {
      this.logger.error(`Erro ao enviar mensagem Telegram para ${chatId}`, error);
    }
  }

  private async sendTelegramReminder(user: any): Promise<void> {
    if (!user.phone) return;

    const message =
      `üëã Ol√°, ${user.name}!\n\n` +
      `üìù Voc√™ ainda n√£o registrou nenhuma transa√ß√£o hoje.\n\n` +
      `Que tal adicionar suas despesas ou receitas do dia?\n\n` +
      `Use /addreceita ou /adddespesa para come√ßar!`;

    await this.sendTelegramMessage(user.phone, message);
  }

  private async sendTelegramWeeklySummary(user: any, data: any): Promise<void> {
    if (!user.phone) return;

    const incomeIcon = data.totalIncome > 0 ? 'üí∞' : 'üíµ';
    const expenseIcon = 'üí≥';
    const balanceIcon = data.balance >= 0 ? '‚úÖ' : '‚ö†Ô∏è';

    const message =
      `üìä *Resumo Semanal*\n\n` +
      `Ol√°, ${user.name}!\n\n` +
      `Aqui est√° o resumo da sua semana:\n\n` +
      `${incomeIcon} Receitas: R$ ${data.totalIncome.toFixed(2)}\n` +
      `${expenseIcon} Despesas: R$ ${data.totalExpenses.toFixed(2)}\n` +
      `${balanceIcon} Saldo: R$ ${data.balance.toFixed(2)}\n\n` +
      `üìù Total de transa√ß√µes: ${data.transactionCount}\n\n` +
      `Continue assim! Use /relatorio para ver mais detalhes.`;

    await this.sendTelegramMessage(user.phone, message);
  }

  private async sendTelegramMonthlyReport(user: any, data: any): Promise<void> {
    if (!user.phone) return;

    const balanceIcon = data.balance >= 0 ? 'üéâ' : '‚ö†Ô∏è';

    const message =
      `üìà *Relat√≥rio Mensal - ${data.month}/${data.year}*\n\n` +
      `Ol√°, ${user.name}!\n\n` +
      `üí∞ Receitas: R$ ${data.totalIncome.toFixed(2)}\n` +
      `üí≥ Despesas: R$ ${data.totalExpenses.toFixed(2)}\n` +
      `${balanceIcon} Saldo: R$ ${data.balance.toFixed(2)}\n\n` +
      `üìù Transa√ß√µes: ${data.transactionCount}\n` +
      `üìä Maior gasto: ${data.topCategory} (R$ ${data.topCategoryAmount.toFixed(2)})\n\n` +
      `Use /graficos para visualizar seus gastos!`;

    await this.sendTelegramMessage(user.phone, message);
  }

  private async sendTelegramBudgetAlert(user: any, alert: any): Promise<void> {
    if (!user.phone) return;

    await this.sendTelegramMessage(user.phone, alert.message);
  }

  private getMonthName(month: number): string {
    const months = [
      'Janeiro', 'Fevereiro', 'Mar√ßo', 'Abril', 'Maio', 'Junho',
      'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'
    ];
    return months[month - 1] || '';
  }

  /**
   * Criar notifica√ß√£o manual
   */
  async createNotification(
    userId: string,
    type: string,
    title: string,
    message: string,
    data?: any
  ) {
    return this.prisma.notification.create({
      data: {
        userId,
        type,
        title,
        message,
        data,
      },
    });
  }

  /**
   * Buscar notifica√ß√µes n√£o lidas de um usu√°rio
   */
  async getUnreadNotifications(userId: string) {
    return this.prisma.notification.findMany({
      where: {
        userId,
        isRead: false,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });
  }

  /**
   * Marcar notifica√ß√£o como lida
   */
  async markAsRead(notificationId: string) {
    return this.prisma.notification.update({
      where: { id: notificationId },
      data: { isRead: true },
    });
  }
}
