import cron from 'node-cron';
import { logger } from '../utils/logger';
import { SessionManager } from '../middleware/session.middleware';
import { ProviderFactory } from '../providers/factory/provider.factory';
import { ApiService } from '../services/api.service';

/**
 * Cron Jobs para automa√ß√£o
 * 
 * Jobs programados:
 * - Resumo di√°rio (6h e 22h)
 * - Limpeza de sess√µes expiradas (di√°rio √†s 3h)
 * - Limpeza de rate limiters (a cada hora)
 */
export class CronJobs {
  /**
   * Inicia todos os cron jobs
   */
  static start(): void {
    logger.info('[CronJobs] Iniciando cron jobs...');

    // Resumo di√°rio da manh√£ (6h)
    cron.schedule('0 6 * * *', async () => {
      await this.sendDailySummary('morning');
    });

    // Resumo di√°rio da noite (22h)
    cron.schedule('0 22 * * *', async () => {
      await this.sendDailySummary('evening');
    });

    // Limpeza de sess√µes expiradas (3h da manh√£)
    cron.schedule('0 3 * * *', () => {
      this.cleanExpiredSessions();
    });

    // Limpeza de rate limiters (a cada hora)
    cron.schedule('0 * * * *', () => {
      logger.debug('[CronJobs] Limpando contadores de rate limit...');
      // RateLimiter j√° limpa automaticamente, mas podemos for√ßar aqui
    });

    logger.info('[CronJobs] ‚úÖ Todos os cron jobs iniciados');
  }

  /**
   * Envia resumo di√°rio para todos os usu√°rios
   */
  private static async sendDailySummary(period: 'morning' | 'evening'): Promise<void> {
    try {
      logger.info(`[CronJobs] Enviando resumo di√°rio (${period})...`);

      const sessionStats = SessionManager.getStatistics();
      let sent = 0;
      let errors = 0;

      // Itera sobre todas as sess√µes ativas
      for (const [phone, session] of (SessionManager as any).sessions.entries()) {
        try {
          // Obt√©m provider do usu√°rio
          const provider = await ProviderFactory.getProvider(
            session.userId,
            phone,
            session.tier
          );

          // Busca resumo di√°rio via API
          const apiService = new ApiService();
          apiService.setToken(session.token);
          
          const summary = await apiService.getDailySummary();

          // Monta mensagem
          let message = '';

          if (period === 'morning') {
            message = `‚òÄÔ∏è *Bom dia!*\n\n`;
            message += `üìä *Resumo de Ontem*\n\n`;
          } else {
            message += `üåô *Boa noite!*\n\n`;
            message += `üìä *Resumo de Hoje*\n\n`;
          }

          message += `üíµ Receitas: R$ ${summary.income?.toFixed(2) || '0.00'}\n`;
          message += `üí∏ Despesas: R$ ${summary.expense?.toFixed(2) || '0.00'}\n`;
          message += `üí∞ Saldo: R$ ${summary.balance?.toFixed(2) || '0.00'}\n\n`;

          if (summary.topCategory) {
            message += `üèÜ Maior gasto: ${summary.topCategory.name} (R$ ${summary.topCategory.amount.toFixed(2)})\n\n`;
          }

          message += period === 'morning' 
            ? 'Tenha um √≥timo dia! üöÄ'
            : 'Descanse bem! üò¥';

          // Envia mensagem
          await provider.sendTextMessage(`whatsapp:${phone}`, message);
          sent++;

          // Aguarda 1s entre mensagens para n√£o sobrecarregar
          await new Promise((resolve) => setTimeout(resolve, 1000));
        } catch (error) {
          logger.error(`[CronJobs] Erro ao enviar resumo para ${phone}:`, error);
          errors++;
        }
      }

      logger.info(
        `[CronJobs] ‚úÖ Resumo di√°rio enviado: ${sent} sucesso, ${errors} erros`
      );
    } catch (error) {
      logger.error('[CronJobs] Erro ao enviar resumos di√°rios:', error);
    }
  }

  /**
   * Limpa sess√µes expiradas
   */
  private static cleanExpiredSessions(): void {
    logger.info('[CronJobs] Limpando sess√µes expiradas...');
    SessionManager.cleanExpiredSessions();
  }

  /**
   * Para todos os cron jobs (√∫til ao encerrar aplica√ß√£o)
   */
  static stop(): void {
    logger.info('[CronJobs] Parando todos os cron jobs...');
    // cron.schedule retorna um objeto com m√©todo .stop()
    // Mas para simplificar, deixamos o Node.js gerenciar
  }
}
